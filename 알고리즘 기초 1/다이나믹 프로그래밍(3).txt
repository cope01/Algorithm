카드 구매하기 : 
마지막에 산 카드팩의 카드 개수 ? 알 수 없음
다이나믹 프로그래밍에서 알 수 없다는 정보가 나오면 모두 해보면 된다.

dp[n] = max(dp[n], dp[n-i] + p[i]); (1 <= i <= n)
시간복잡도 : O(N^2)

카드 구매하기 2 : 
위의 문제와 반대로 하면 된다.
그러나 초기값을 0으로 만들어두면 0과 비교를 해서 최솟값을 출력하게 되기 때문에
초기값을 미리 설정해줘야 한다. 나는 dp[n] = p[n]으로 초기값을 설정해주었다.

백준님은 -1로 초기화하거나 아주 큰 값으로 초기화를 해준다.
-1로 초기화한 경우에는 -1일때만 점화식을 사용

1, 2, 3 더하기 5
!!연속이라는 정보가 추가되었는데,
연속이라는 정보가 추가된 경우에는 두개씩으로 나눌 수 있다.
ㅁㅁㅁㅁㅁ
ㅡㅡ
 ㅡㅡ
   ㅡㅡ
     ㅡㅡ
!!점화식의 정의 : D[i][j]; i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j
그래서 j와 같지 않은 수를 사용할 수 있게 한다.

dp[i][1] = dp[i-1][2] + dp[i-1][3];
dp[i][2] = dp[i-2][1] + dp[i-2][3];
dp[i][3] = dp[i-3][1] + dp[i-3][2];

쉬운 계단 수
점화식의 정의 dp[n][l] : l은 마지막으로 사용한 수.
dp[n][l] = dp[n-1][l-1] + dp[n-1][l+1];
주의) 0과 9는 위의 점화식이 안되서 예외적으로 처리해줘야 한다.

이친수

1과 0으로만 이루어진 수를 이친수라고 한다.
dp[n][l] : n자리, 마지막에 나온 수 l

dp[n][1] = dp[n-1][0]
dp[n][0] = dp[n-1][0] + dp[n-1][1]

dp[1][0] = 0
dp[1][1] = 1
dp[2][0] = 1
dp[2][1] = 0