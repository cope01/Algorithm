다이나믹 프로그래밍
- 큰 문제를 작은 문제로 나누어 푸는 알고리즘.

큰 문제를 작은 문제로 나누는 문제
1) 다이나믹 프로그래밍 (DP : Dynamic Programming)
2) 분할 정복 (D&C : divide and conquer)

차이점은
다이나믹 프로그래밍은 작은 문제가 중복이 가능.
분할 정복은 작은 문제가 중복이 되지 않는다. 개별적으로 다 풀어주는 문제인듯.

 다이나믹
ex) 40명이면 10 30 15 25 이렇게 사람을 나누는 것
 분할 정복
ex) 왼쪽, 오른쪽 이렇게 나누어 중복이 발생하지 않게 나누는 것. 같은 구성 발생하지 않음.

다이나믹으로 풀 수 있는 문제의 속성)
1. Overlapping Subproblem : 겹치는 부분문제
2. Optimal Substructure : 최적 부분 구조. 문제의 정답이 작은 문제의 정답을 통해서 구할 수 있다.

피보나치
p[n] = p[n-1] + p[n-2] 
큰	작은	작은

문제의 정답을 작은 문제의 정답을 통해 구할 수 있다.

서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
대전에서 부산을 가는 가장 빠른 길을 대구를 거쳐야 한다.

문제의 정답은 항상 같아야 한다. 또 같다.

10번째 피보나치 수를 구하면서 구한 4번째 피보나치수
9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수...
문제의 정답이 같은데 여러번 구하면 비효율적
이때 여러 번 구할 필요없이 메모를 해둬야 하는데
이것이 메모이제이션(Memoization)

구현 방식
- top-down 재귀
- bottom-up 루프 
하나를 선택해서 그것에 대해 연습하면 된다.

1. 재귀와 반복문의 시간차이? -> 알 수 없다.
재귀를 쓰면 스택을 쓰므로 스택 오버플로우 발생할 수 있고, 함수 호출 시간.. 
재귀가 오래 걸릴 것 같은데??
실제로는 아닌 경우가 많다. 간단하게 구할 수 있다.
스택오버플로우 발생하면 점화식을 잘못 구한 것.
-> 암튼 고민할 필요 별로 없다

2. 
Top-down 으로만 풀 수 있는,
Bottom-up 으로만 풀 수 있는 문제
존재한다.
이런 문제들을 풀 수 있으면 둘 다 잘 구현할 수 있을 것.

문제 풀이 전략
1) 점화식의 정의를 통해 점화식을 만든다.
