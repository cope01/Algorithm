// 출처 : https://blog.naver.com/kks227/220791188929 (rie's blog)

priority_queue<T, Container, Compare> : 원하는 자료형 및 클래스 T를 통해 생성. 여기서 Container는 vector와 같은 컨테이너이며 Compare는 비교함수 클래스이다.

우선순위 큐
큐가 이름 뒤에 붙어있듯 push, top, pop 연산밖에 없다. 사용 방법은 queue 와 동일하며
#include <queue> 를 추가하면 prioirty_queue도 사용할 수 있다.

** 우선순위 큐 우선순위를 설정하는 방법 ** 
// 출처 : https://koosaga.com/9
struct cmp{
    bool operator()(pair <int, int> a, pair <int, int> b){
        if(a.first < b.first){
            return a.second > b.second;
        }
        return a.first < b.first;
    }
}

이름은 큐지만 내부 구조는 큐와 완전히 다르다.
top(), pop()에서 추출되는 원소는 제일 먼저 들어왔던게 아닌 현재 우선순위 큐 안에서 제일 우선순위가 높은 원소가 된다.

가장 유명하고 많이 쓰이는 형태는 클수록 우선순위가 높은 형태, 작을수록 우선순위가 높은 형태이다
우선순위 큐의 default는 클수록 우선순위가 높은 형태가 된다. (= 최대 힙)
즉, priority_queue <int> pq; 라고 그냥 설정하게 되면 클수록 우선순위가 높은 형태가 된다. 
작을 수록 우선순위가 높게 설정하려면
priority_queue <int, vector <int>, greater <int> > pq라고 설정하면 된다.

우선순위 큐는 보통 힙(heap)이라는 자료구조로 구현이 된다.
보통은 동의어로 많이 사용하고, 그래서 top이 최댓값인 우선순위 큐를 최대 힙, 최솟값인 우선순위 큐를 최소 힙이라고 부르기도 한다.
이를 이용한 정렬 방법이 heap sort이다.

힙은 이진 트리의 형태를 지닌다.(심지어 완전 이진 트리이다.)
이 트리에서 제일 중요한 성질은!
** 모든 정점은 자신의 자식들보다 우선순위가 높다 ** 라는 것이다.
주의할 점은 이 성질은 바로 인접한 부모-자식 간에서만 성질이 성립하기 때문에
때에 따라 깊이는 더 깊은데 오히려 더 얕은 곳의 노드보다 우선순위가 높기도 하다.

그렇다면 top()을 하면 제일 먼저 튀어나오는 원소는 ? -> 루트(root)이다.
루트는 힙의 정점에 있기 때문에 어떤 노드보다도 우선순위가 크거나 같다(보통 크겠지) 따라서 우선순위 면에서 최대이다.

그래서 push, pop을 할때마다 힙의 형태를 유지시켜 줘야 하기 때문에 변형이 자주 발생한다.
이렇게 하고 힙의 조건을 유지하도록 부모와 자리를 바꿔가는 연산만 반복해주면 삽입이 끝나게 된다.
힙을 구현하는 가장 간단한 방법은 배열을 이용하는 것인데. 
이때 루트를 ** 0번이 아니라 1번 인덱스로 설정해 줘야 한다. **
이렇게 인덱스를 매기게 되면
왼쪽 자식의 인덱스는 i*2, 오른쪽 자식의 인덱스는 i*2 + 1이 되어 부모와 자식을 찾아가기가 매우 수월해진다.

삽입은 리프 노드에 추가해주고 이를 우선순위에 맞게 해서 부모와 자리를 변경시켜 주면서 성립할때까지 진행을 하면 되며,
삭제는 리프 노드에 있는 것을 루트에 추가해주고 이를 자식과 자리를 변경시켜주면서 성립할때까지 진행을 하면 된다.

찾기, 삽입, 삭제 작업을 모두 O(logN)만에 수행이 가능하다.
이로써 힙 소트 역시 N개를 차례차례 빼서 얹어놓으면 되는 것이기 때문에 O(NlogN)이라고 짐작 가능하다.

