2011 : 암호 코드
나머지를 1000000으로 나눈 나머지
암호를 해독할 수 없는 경우에는 0.
숫자로 이루어진 암호라고 했는데 해독을 못하는 경우가 있을 수 있나?
0같은 숫자는 해독할 수 없겠네.
또?
일단 0으로 시작하는 숫자는 해독 불가능.
str[0] == 0이면 0을 출력하고 종료하는 것으로 하자.


일단 겹치는 부분이 있으면
예를 들어 114같은 수가 있으면
11로 한 문자를 만들 수도 있고, 14로 한 문자를 만들 수도 있다.

25114

그래서

25를 합치는 경우, 2, 5 를 각각 따로 보는 경우 2가지가 있고,

51은 합칠 수 없다. 1가지

114는 11로 묶는 경우, 14로 묶는 경우, 1, 1, 4 다 따로 보는 경우 3가지,

그래서 2 * 3을 해서 경우 6가지가 나오는 것이다.


각 구간을 나눠서 생각해야 하나?
25
51
11
14 
이렇게?
만약 그런 식으로 나눈다고 하면 114는 어떻게 처리를 해야 하는가?
일단 해보자.

만약에 11111이면?
다 해보니.
8가지 경우가 나온다

일단 1)방법이라고 하고 제쳐두고,

2)
작은 것부터 차례대로 해보자.
원래 다이나믹프로그래밍이 작은것으로나눠서푸는거니까
작은것부터해보자
dp[1 ~ 10] = 1
dp[11 ~ 26] = 2
dp[27 ~ 99] = 1
dp[100]

풀이보고 정리 :
dp[1] 부터 저장한다.
일단 문자들을 str배열에 입력받는다.
그 후 한칸씩 오른쪽으로 이동하면서 검사를 한다.
i 라는 iteration을 통해서 문자열 마지막까지 검사를 한다.
x = str[i - 1] - '0'
이라고 하고 x >= 1 && x <= 9 검사하여
이에 성립되면 
dp[i] += dp[i-1];
dp[i] = dp[i] % MOD;
y = (str[i - 1] - '0') * 10 + str[i - 2] - '0'
이라고 하고 y >= 10 && y <= 26 검사하여
이에 성립되면
dp[i] += dp[i-2];
dp[i] = dp[i] % MOD라고 하고 추가를 해준다.

그리고 마지막에는 문자열의 마지막에 저장된 dp를 출력해주면 된다.

여기서 예외들은 모두 처리가 되는데,
저기 범위에 저장되지 않은 것은 전부 기본값인 0을 출력하게 된다.

그래서 따로 예외처리를 해줄 필요가 없다.

