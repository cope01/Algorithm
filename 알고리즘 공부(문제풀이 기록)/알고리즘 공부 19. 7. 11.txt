1912 연속합
	// dp에 저장할 대상. i의 인덱스에 있을 경우. 
	// 1) a[i-1] 까지의 따졌을때 연속합 최고인 경우. 이것을 그냥 dp로. 
	// 2) a[i]
	// 1), 2) 중 큰 값을 골라서 dp[i]에 저장한다.

	dp[i]중 최댓값을 출력하면 된다.

2579 계단 오르기 -> 풀이 봤음
	// 마지막 계단 밟는 것과 경우의 수 찾는게 핵심 

	// 계단 밟으면 쓰여진 점수를 얻는다.
	// 연속된 세 개의 계단을 모두 밟아서는 안된다.
	// 계단은 첫번째, 두번째 계단 오를 수 있다. 
	// 시작점은 계단에 포함되지 않는다. 첫번째 계단 ㄴㄴ 오해 ㄴ 
	// 마지막 계단은 꼭 밟아야 한다.
	 	
	// 마지막 계단을 밟아야 되기 때문에 복잡해진다.
	// 마지막 계단 빼고 생각.
	// 그러면 i에서 시작하면. i 까지 최고점수를 dp[i]에 저장해야 됨.
	 
	// 세번째부터는 이렇게 두가지로 나누는게 애매해지니까
	// 세가지로 나누는건 어떨까?
	// dp[3] 에선 a[1] + a[2], a[1] + a[3], a[2] + a[3]
	// dp[4] 에선 a[1] + a[2] + a[4] , a[2] + a[3] + a[4] , a[2] + a[ 
	// 세가지로 나누는건 아닌듯 
	
	// dp[1] = a[1] 
	// dp[2] = a[1] + a[2]
	// dp[3] = a[1] + a[2] 즉, dp[2] 와 a[1] + a[3] 을 비교해서 큰 값을 저장.
	// 그러면 a[2] + a[3] 은?
	// a[1] + a[2] + a[3] 에서 a[1], a[2], a[3] 중 최솟값 하나를 빼고
	// 그것을 dp[3] 에 저장하면 될듯
	// dp[3] = (a[1] + a[2] + a[3]) - a[?];
	// dp[4] = a[1] + a[2] + a[3] + a[4]

1 2 4 o
1 3 4 o
2 3 4 x

2계단이 연속했으면
앞 뒤 하나씩 비어야 한다.

-> 여기서 풀이를 봤다.
1. 마지막 계단 전의 계단을 밟은 경우.
2. 마지막 계단 전의 계단을 밟지 않은 경우.

1번의 경우에는 마지막 계단 전의 계단을 밟았음으로, 
마지막 계단 전전의 계단은 밟지 못한다.
2번의 경우에는 마지막 계단 전의 계단을 밟지 않았음으로, 
마지막 계단 전전의 계단을 밟고 왔다.

위 경우를 통해 점화식을 도출해보자.

1. dp[n] = dp[n-3] + array[n-1] + array[n]
2. dp[n] = dp[n-2] + array[n]

출처: https://mygumi.tistory.com/100 [마이구미의 HelloWorld]

dp는 큰 문제를 작게 나눠서 생각하는 것.
여기서는 마지막 계단을 밟는다는 것이 핵심.
dp[n]을 구하는 것임.
그러면 작은 dp도 바로 그 계단을 밟는다는 것으로 접근을 하면 된다.
i를 밟는지 아닌지 조사하면 된다.

