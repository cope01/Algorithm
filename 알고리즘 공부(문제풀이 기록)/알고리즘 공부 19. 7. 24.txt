2579 계단 오르기 다시 풀기.

현재의 것을 dp로 삼아서 해야 한다.
1. 계단은 한번에 한 계단씩 또는 두 계단씩 오를 수 있다.
즉 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안된다. 단, 시작점은 계단으로 포함하지 않는다.(시작점은 첫번째 계단이 아니라 그냥 시작점)
3. 마지막 도착 계단은 반드시 밟아야 한다.

계단 수 입력
배열에 계단에 기록된 점수 입력(배열은 a[]라고 하자.)
dp배열 생성
dp[1] 이 첫번째 계단이라고 한다.
dp[1] = a[1];
dp[2] = a[1] + a[2];

dp[3] 부터 규칙성이 필요하다.
for(i = 3; i <= n; ++i){ 
	dp[i-3] + a[i-1] + a[i]
	dp[i-2] + a[i]
}
둘중 최대 골라서 
마지막에 dp[n]을 출력하면 된다.

1699 제곱 수의 합.

n이라는 자연수를 입력받아서,
제곱수의 합으로 표현을 하면되는데
제곱수 합으로 표현을 할 때에 그 항의 최소 개수를 구하면 되는 문제이다.
자연수 n은 100000보다 작은 수.
1 4 9 16 25 36 49 64...
큰수부터 채운다고 해도 최소 개수가 되지는 않는다.
예를 들면,
72라는 숫자가 있으면
64부터 채우면 8이남고
그러면 4 4
64 4 4로 표현.
근데
36 36 으로도 표현 가능하다.
따라서 이런 경우로 하면 너무 많은 경우를 만들어야 하기 때문에 이 방법은 아닐 것.
따라서 dp로 풀어야 한다

참고 사이트 http://blog.naver.com/PostView.nhn?blogId=oncoder-hs&logNo=221323255829&parentCategoryNo=&categoryNo=1&viewDate=&isShowPopularPosts=true&from=search

knapsack 알고리즘.
도둑이 들었다.
무게와 가치가 정해진 보석이 있고 허용된 배낭 범위안에 보석을 고효율로 집어 넣어야 한다.
넣을지/안넣을지 두 가지 경우가 있다.
이를 0/1 Knapsack이라고 부른다.

동적 계획법을 해결할때는 이미 답을 뱉어내는 함수를 내가 가지고 있다고 가정해야 쉽게 생각을 전개시킬 수 있다.(달리 말하면 부분문제 역시 최종 정답의 축소판. 만약 dp[n]을 구하고자 한다면 그 과정에 있는 dp[i]역시도 답을 담고 있는 것이어야 한다.)

f(i,k)라는 함수를 정의(가정)해보자.
f(i, k) = 1 ~ i번째 보석만을 가지고, 배낭 크기 k를 채웠을 때의 최대 가치.
이 식을 어떻게 푸는 지는 아무도 모른다. 그냥 가정하는 것이 가장 중요. 저 함수의 실제 답을 찾는 방법은 이 식이 옳다고 판단하고 나서 해도 늦지 않다.

f(i, k)
식으로 옮겨보면 100 개의 보석이라고 치자.
1-99번째 보석만 가지고 배냥 크기 (K-Wa)를 채울 수 있는 최대 가치.
식으로 옮기면 f(99, K-Wa)이다. 그리고 우리가 현재 구하고자 하는 값은 
f(100,k)
그리고 100번째 보석을 넣지 않고 1-99번째 보석만 가지고 K배낭을 다 채워버린 경우는 f(99,k)

우리는 f(99, K-Wa)와 f(99, K)중 어떤 것이 더 큰지만 알면 f(100, K)의 답을 구할 수 있다.
결론적으로 식은)
f(100, K) = max(f(99,k -Wa) + Va, f(99, K))
이다. Va가 추가된 이유는 100번째 보석인 보석 a를 넣었기 때문에 얻을 수 있는 가치.

수식으로 옮기면 
f(i,k) = max(f(i-1, k-w[i] + v[i]), f(i-1, k))
이다.

그렇다면 이것을 제곱수의 합에 적용시켜보자.

n을 입력받는다.
317^2까지 하면 100000범위안을 포함할 수 있다.
여기서는 n을 입력받기 때문에 k * k <= n 인 k를 사용하면 된다.
여기서 가치는 모두 동일하게 1이다.(횟수)










	
