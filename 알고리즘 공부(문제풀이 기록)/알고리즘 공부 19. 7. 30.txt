2225번 : 합분해

0부터 N까지의 정수 K개를 더해서 합이 N이 되는 경우의 수를 구하는 프로그램.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다.
1 + 2 와 2 + 1은 다르다.
두 개의 수의 합만 이렇게 되는 것이 아니고 세개, 네개 다 적용되겠지.
1 + 2 + 1과 1 + 1 + 2와 2 + 1 + 1은 다 다른 거.

한 개의 수를 여러번 쓰는 것도 가능.

첫째 줄에 두 정수 N, K가 주어진다.
첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

예제1)
20 2

0 20
1 19
2 18
...
18 2
19 1
20 0

예제2)
20 3

첫번째 수가 0인 경우(위의 dp를 받는다.)
0 0 20
0 1 19
0 2 18
...
0 20 0(20 2와 동일)

1 0 19
1 1 18
1 2 17
...
1 18 1
1 19 0(19 2와 동일)

(18 2)
(17 2)
(16 2)
...
(2 2)
(1 2)
(0 2)

0 2 ~ 20 2까지의 합을 다 더한 것.
예제 3)
20 4
0 0 0 20
0 0 1 19
...
0 0 20 0

0 3 ~ 20 3까지의 합을 다 더한 것.

이렇게 풀면 된다.

우선 n, 2는 쉽게 뽑을 수 있을 것.
0 2는 0 0(1가지)
1 2는 1 0, 0 1(2가지)
2 2는 0 2, 1 1, 2 0(3가지)
3 2는 0 3, 1 2, 2 1, 0 3

(n, 2)는 n + 1이 답이다.
(n, 3)은 
for(i = 0; i <= n; ++i){
	sum += (i, 2);
}

(n, 4)역시 
for(i = 0; i <= n; ++i){
	sum += (i, 3);
}

그러면 답 나왔네.
주의해야 될 부분은 n = 0인 경우가 답에는 포함되어 있지 않지만
dp를 만드는 일반형태의 식에 넣어줘야 한다는 점.

근데
1 5의 경우에
내 식은 3이 답이 나오는데
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0 
0 0 0 1 0
0 0 0 0 1

이렇게 5가지의 경우가 나와야 한다.

풀이를 보았다.
이해가 안됨.

다시 적어보았다.
위에서 빠뜨린 부분은
dp[20][3] = dp[20][2] + dp[19][2] + ...
이런 식으로 앞의 수가 줄어든다는 것.

dp[20][3] = dp[20][2] + dp[19][2] + ... + dp[0][2]
dp[20][4] = dp[20][3] + dp[19][3] + ... + dp[0][3]
이런 식으로 된다.

그래서 낮은 수부터 차례대로 빈틈없이 채워나가야 한다
식을 만들어보면
dp[n][k] = dp[0][k-1] + ... + dp[n][k-1]이렇게 다 채워넣어야 하는데
그러기 위해서는 0 ~ n 까지를 표현해줄 변수가 필요한데 그것이 l이었다.
l을 이용하지 않고 처음 생각대로 이중 루프를 이용하게되면
dp[0][3] += dp[0][2]넘어가고
dp[1][3] += dp[1][2]하고 바로 넘어가고
이런 식으로 된다.
그래서 
for(l = 0; l <= j; ++l){
	dp[j][i] += dp[l][i-1];
	dp[j][i] %= MOD;
}
를 이중루프 안에 적어주니 원래 원하는 대로 식이 만들어졌다.

