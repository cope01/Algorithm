1699 제곱수의 합. 냅색 알고리즘이라고 한다. 

냅색 문제는 유명한 다이나믹 문제 중 하나이다.

가장 유치하지만 또 가장 많이 쓰이는 설명으로는,
한 가게에 도둑이 들었다. 도둑이 훔치고 싶은 물건들은 다 각각의 값어치와 무게가 있다.
무게 때문에 도둑은 고를 수 있는 물건이 한정되어 있다.
그러므로 가방에 다 담을 수 있는 내에서 가장 비싼 물건을 훔치고자 한다.
여기서 세 가지 선택이 있다.

1) 모든 경우를 다 세어본다.
물건의 갯수가 n개라면, 각각의 물건은 ( 가방에 넣는가, 안 넣는가 ) 의 두 가지 경우가 있다.
전부 2^n가지의 경우를 세어보면 된다.

2) 넣을 수 있는 가장 비싼 물건부터 넣는다. (Greedy Algorithm)
그럴듯 하지만 생각한것처럼 최적의 해는 나오지 않는다. 예를 들어
$10 / 13 kg
$6 / 6 kg
$5 / 6 kg
가방 15 kg

이라면 6$,5$짜리를 택하는 편이 낫다.

3) 동적 계획법(dynamic programming)을 사용합니다.

dyn[i][j] = (가방의 크기가 i일때, j번째 물건까지 담을 수 있는 경우 최대 가치)라고 하면,
dyn[0][i] = dyn[j][0]= 0 를 base case로 놓을 수 있다.
그렇다면 점화식을 구해보자.

i가 weight[j]보다 크거나 같으면 이 가방엔 이 물건이 들어갈 수 있다.
그렇다면 j번째 물건을 넣는다고 가정했을 때,
((i-weight[j]) 크기의 가방에 (j-1) 번째 물건까지 넣을 수 있는 경우 최대 가치)에다가 value[j]를 더하는 모든 경우가 가능하다.
어느 것이 최대인가는 경우에 따라 다르기 때문에 시도해봐야 한다.
이 물건을 안 넣기로 하거나 가방 크기때문에 넣을 수 없다면,
i번째 가방에 j-1번째 물건을 넣을 수 있는 경우 최대 가치를 그대로 쓸 수 있다.

i≥weight[j]이면 dyn[i][j]=max(dyn[i][j-1],max(dyn[i-weight[j]][j]+value[j]))
i<weight[j]이면 dyn[i][j]=dyn[i][j-1]

이렇게 하면 답은 dyn[가방 크기][마지막 물건].

-> 내 생각
이 문제에 처음으로 생각했던 것은. 여기의 2번 방법처럼 큰수 순서대로 때려 넣으면 된다는 접근이었는데
그렇게 넣으면 안되는 경우가 있을 거라는 생각을 했음.
그리고 예시를 찾았는데
18같은 경우 9랑 9넣으면 2개로 되는데 16넣으면 1 1 넣어서 3개가 되야 함.

그래서 이 방법은 아니라고 생각이 듬.

그 후 위의 1번 방법처럼 필요한 수 1개인 경우부터 넣고, 2개로 표현가능한 수를
넣었는데 일단 이부분부터 O(n^2)가 되서 10만의 제곱으로 시간초과할 것이라고 생각됨.

그래서 다시 돌아와서 dp로 해야겠다고 생각이 들었는데
dp[i^2] = 1인것 이후에
2, 3 이런 식으로 채워넣으려고 했는데, 
dp[i^2 + 1] = 2
dp[i^2 + 4] = 2
dp[i^2 + 9] = 2
세번째 경우에 16 25라는 예외의 경우가 있어서, 포기하고 풀이를 봄.


1. 이 문제는 제곱수를 만드는 건데 현재의 제곱수의 최소값을 위해서 이전의 최소값을 이용하여서 최소값을 만든다.
2. 검색의 범위는 제곱수기 때문에 1 부터 j * j <=i 까지로 충분하다. 그러므로 검색시간을 줄일 수 있다. 
3. 즉 Dp[i] = Dp[i - j*j] + 1 라는 식이 나오는데 이 식은 j*j 수의 제곱수 값 1 + 이전에 값 Dp[i- j*j] 값으로 구 할수 있다. 
4. 하지만 j의 최대값만으로 하면 예외 조건이 생길 수 수 있으므로 1~ j의 최대값까지 전부 비교 해야한다. 그 예외 조건의 예시는 12가 있다.
- 12 = 3*3 + 1*1 + 1*1 + 1*1 = 4
- 12 = 2*2 + 2*2 + 2*2 = 3 

내가 생각한 방식과 약간 유사하긴 한데. j*j <= i. i보다 큰 값 제곱수를 빼진 않을거니까
이 것을 생각하는 것이 중요하고, 빼는 것으로 생각을 해야 불필요한 일을 덜할 수 있다.


