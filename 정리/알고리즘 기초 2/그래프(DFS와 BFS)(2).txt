그래프의 표현 : 그래프의 정점과 간선을 저장하는 것.
정점은 정점의 수를 저장하면 된다.
간선을 저장하는 것이 핵씸!

그래프 저장 방법
효율의 문제가 생긴다.
*한 정점 X와 연결된 간선을 효율적으로 찾는 구조를 만드는 것*
1. 인접 행렬 
- 2차원 배열에 연결되어 있으면 1, 연결안되어 있으면 0을 저장하면 된다.
ex) 1과 5가 연결되어 있으면 a[1][5] = a[5][1] = 1을 해주면 된다.
가중치가 있으면 가중치를 넣어주면 된다.
정점 V 간선 E개 있으면,

공간복잡도 O(V^2)
하나의 정점과 연결된 모든 간선 찾는 시간복잡도 O(V)

2. 인접 리스트
리스트로 표현하는 주요 이유는 몇개를 사용할지 모르기 때문에.
간선이 있을때마다 하나씩 증가하는 방법을 사용한다.
A[1] 2 5
A[2] 1 3 4 5
이런 식으로 연결되어 있는 정점을 저장.

공간복잡도 O(E)
시간복잡도 O(차수)

// 가중치가 있는 경우
A[1] (2,2), (5,3) // 연결된 정점과 가중치를 묶어서 저장해주면 된다.

**
임의의 두 정점사이에 간선이 있는지 없는지를 구하는 시간에서만 인접행렬이 인접리스트보다 뛰어나다
인접행렬 : O(1) 인접리스트 : O(차수)
그 외의 경우에는 모두 인접리스트가 인접행렬보다 뛰어나기때문에. 우리는 인접리스트를 사용할 것.
**

리스트는 크기를 동적으로 변경할 수 있어야 한다.
링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.

** 그래프1 pdf자료 참고.
간선 리스트 : 사용할 때)인접리스트를 활용해야하는데 라이브러리 사용이 금지되어 있을 때.
배열을 이용해서 구현한다.
간선을 모두 저장하고 있다.
E 라는 1차원배열에다 간선을 모두 저장한다.(간선과 연결된 정점)
E[0] = 1 2
E[1] = 1 5
E[2] = 2 1 ...
이렇게 해서 모두 구하고,
각각의 간선을 정렬하고 cnt[]라는 배열에 저장하고
이 cnt값들을 누적해서 ..

하나의 정점과 연결된 모든 간선 O(차수)만에 구할 수 있다.

