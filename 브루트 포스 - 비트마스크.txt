!! 연산자 우선순위
비트연산자는 곱셈과 덧셈보다 연산자우선순위가 낮다. 헷갈리면 괄호를 이용하자.

비트마스크)
bit연산을 이용해서 부분 집합을 표현할 수 있다.
비트 연산
and(&), or(|), not(~), xor(^)

수도 비트연산이 가능하다.

두 수 A과 B를 비트연산하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다.
not 연산의 경우에는 자료형에 따라 결과가 달라진다. (몇 비트인지에 따라 앞에 1, 0이 달라짐)

unsigned 인지, signed 인지에 따라 보여지는 값이 다르다 
(내부에 저장되는 비트는 같으나)

1 << 0 == 1
1 << 1 == 2
1 << 2 == 4
1 << 3 == 8
1 << 4 == 16
3 << 3 == 24
5 << 10 == 5*1024 = 5120

1 >> 0 == 1
1 >> 1 == 0
10 >> 1 == 5
10 >> 2 == 2 10/4와 같다.

1<<N을 하면 2^N을 바로 구할 수 있다.
(A+B)/2 == (A+B)>>1

정수로 집합을 나타낼 수 있다.
{1, 3, 4, 5, 9} = 570 = 2^1 + 2^3 ... + 2^9
장점
1) 비트를 이용해서 구하려면 570은 10비트가 필요한데,
570이라는 수로 단순하게 나타낼 수 있다. 
2) 배열안에도 사용가능하다 A[570]

보통 0에서 N-1까지 정수로 이루어진 집합을 나타낼 때 사용한다.
1~N까지 정수로 이루어진 집합을 사용하는 것은 공간이 2배 더 필요하다.
또, 각종 연산을 조금 변형해서 사용해야 한다. 시간도 2배 더 필요하다.
따라서 0 ~ N-1까지로 변형해서 사용하는 것이 더 좋다.(더 좋은게 아니라 반드시!)

570 = {1, 3, 4, 5, 9} == 1000111010
검사 연산)
해당 비트와 &연산을 하고 -> 결과가 0인지 0이 아닌지를 검사해주면 된다.
결과가 0이 아니면 값이 들어있는 것.
570 & 2^1 = 570 & (1<<1) == 0 or not 0

추가 연산)
해당 비트와 |연산을 하면 된다.
570 | 2^1 = 570 | (1<<1) == 570 or not 570

제거 연산)
570 & ~2^1( 해당 숫자를 제거한 것)
해당 숫자를 not 을 통해서 제거해서 1111101111 (0은 해당숫자의 위치)로 만들어주고
이를 전체를 포함하는 숫자와 &연산을 해주면 그 숫자만 없어진 다른 것은 포함하는 숫자가 나오게 된다.

Xor(^))은 토글연산 바로해주면된다.

전체 집합
-> (1 << N) -1 ( 0 ~ N-1)
공집합
-> 0



